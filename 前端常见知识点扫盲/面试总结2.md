# 面试题目总结第三部分 -- this和原型链

### 关于this

> this 表示的是函数调用时，对当前执行上下文的一个引用（或者叫活动记录）。包括调用栈（在哪儿被调用）、调用方式、传入参数；

绑定规则：    

> 1、默认独立函数调用，如下：

```
function a(){
  console.log(this.b);
}
var b = 1;
a(); // 输出 b;

/*
** 这个this指向的是全局作用域，
** 也是就是平常的window或者global;
*/
```
> 2、隐式绑定

```
function a(){
  console.log(this.b);
}
var c = {
  "b": "this is b",
  a: a
}
c.a(); // 输出： this is b;

/*
** 这个this指向的是引用的 c ，
** 隐式绑定会将引用放到这个上下文对象上去;
*/

// 下面是一个极端例子，请注意：

function foo(){
  console.log(this.a);
}

function actFoo(fn){
  fn();
}

var obj = {
  a: "obj's a",
  foo: foo
}

var a = "global";

actFoo(obj.foo); // 输出： global;

// 丢失了this，导致this指向了global;
// 所以才会有下面的显示绑定


```

> 3、显示绑定

```
function foo(){
  console.log(this.a);
}
var obj = {
  a: 2
};
var a = 1;
foo.call(obj); // 输出 2;

/*
** 当你传入一个原始值（bool, string, number）,
** 会被当做this的绑定对象原始值会被转换成对象形式
**（执行了New String(), new Boolen()），叫做装箱操作。
*/

// PS： 无法解决绑定丢失问题。
```

> 4、硬绑定

```
function foo(){
  console.log(this.a);
}
var obj = {
  a: 2
};
var bar = function(){
  foo.call(obj);
}
bar(); // 输出 2
var a = 1;
bar.call(global) // 输出 2;

// 平常常用的还有：apply、bind等

```

> 5、使用 new 进行绑定

使用new，例如 var obj = new Object(),会执行以下逻辑：            
a、创建或者构造一个全新对象；              
b、对象会被执行[[Prototype]]连接；                
c、新对象会绑定到函数调用的this;
d、如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象；
```
function foo(a){
  this.a = a;
}
var bar = new foo(2);
console.log(bar.a); // 2
```

> 6、优先级：

new ？ 显式绑定 > 隐式绑定 > 默认绑定

### 原型链

##### 函数与对象不同属性

> 所有 **引用类型（函数，数组，对象）** 都拥有 \__proto__ 属性（隐式原型）    
> 所有 **函数** 拥有 prototype 属性（显式原型）（仅限函数）    
> 原型对象：拥有 prototype 属性的对象，在定义函数时就被创建

上面描述内容示意图分别如下：      

```
// ps: __proto__不是规范属性，标准的属性是：[[Prototype]]

////////////  示例1：//////////////

var a = {};
console.log(a.prototype);  //undefined
console.log(a.__proto__);  //Object {}

var b = function(){}
console.log(b.prototype);  //b {}
console.log(b.__proto__);  //function() {}
```
解释：
> objects --> \__proto__   引用类型的属性    
> functions --> prototype  函数具有的属性

#### \__proto__指向谁？

```
///////////////////////// 示例2： ///////////////////////

/*1、字面量方式*/
var a = {};
console.log(a.__proto__);  //Object {}

console.log(a.__proto__ === a.constructor.prototype); //true

/*2、构造器方式*/
var A = function(){};
var a = new A();
console.log(a.__proto__); //A {}

console.log(a.__proto__ === a.constructor.prototype); //true

/*3、Object.create()方式*/
var a1 = {a:1}
var a2 = Object.create(a1);
console.log(a2.__proto__); //Object {a: 1}

console.log(a.__proto__ === a.constructor.prototype); //false（此处即为图1中的例外情况）
```
解释：
> a、字面量 \__proto__ 指向 function Object 的 prototype      
> b、构造器生成的对象 \__proto__ 指向 构造器函数的 prototype     
> c、Object.create 生成的对象 \__proto__ 指向 传入对象      

#### 原型链是什么？

//////////////////////////  示例3：///////////////////////

```
var A = function(){};
var a = new A();
console.log(a.__proto__); //A {}（即构造器function A 的原型对象）
console.log(a.__proto__.__proto__); //Object {}（即构造器function Object 的原型对象）
console.log(a.__proto__.__proto__.__proto__); //null
```
解释：
> 1、实际上，我们使用的是 A 的 prototype 来访问的它；     
> 2、a的 \__proto__ 指向的就是 A的 prototype       
> 3、A的 prototype 的 \__proto__ 指向 Object.prototype         
> 4、Object.prototype 指向 自己的构造器,
> 5、Object.prototype 的  \__proto__ ，是一个null，为整个链条终点。
